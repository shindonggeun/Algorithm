class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int answer = 0;
        // dp 배열 생성
        int[][] dp = new int[n+1][m+1]; // [1][1] ~ [n][m]
        
        // 물에 잠긴 좌표 배열 탐색
        for (int[] puddle: puddles) {
            dp[puddle[1]][puddle[0]] = -1; // 물에 잠긴곳은 -1로 표시 (이동할 수 없음)
        }
        
        dp[1][1] = 1; // 시작점([1][1]) 1로 초기화 (집에서 출발하는 경로는 1개이므로)
        
        // 지도의 각 좌표들 순회하면서 경우의 수 계산
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=m; j++) {
                // 물에 잠긴 지역(-1)인 경우 (즉, 이동할 수 없는 경우)
                if (dp[i][j] == -1) {
                    dp[i][j] = 0; // 물에 잠긴 곳은 경로가 없으므로 0으로 설정
                    continue; // 물에 잠긴 곳은 더 이상 처리하지 않으므로 다음 좌표로 건너뜀
                }
                
                // 첫 번째 행보다 큰 경우
                // 첫 번째 행(i=1)은 위쪽이 없으므로, 위에서 오는 경로를 더하지 않음
                // 그러므로 위쪽에서 오는 경로를 더해주려면 첫 번째 행보다 큰 경우를 따져줘야함
                if (i > 1) {
                    dp[i][j] += dp[i-1][j]; // 해당 좌표에 위쪽에서 오는 경로의 수를 더해줌
                }
                
                // 첫번째 열보다 큰 경우
                // 첫 번째 열(j=1)은 왼쪽이 없으므로, 왼쪽에서 오는 경로를 더하지 않음
                // 그러므로 왼쪽에서 오는 경로를 더해주려면 첫 번째 열보다 큰 경우를 따져줘야함
                if (j > 1) {
                    dp[i][j] += dp[i][j-1]; // 해당 좌표에 왼쪽에서 오는 경로의 수를 더해줌
                }
                
                // 경로의 수가 매우 커질 수 있으므로 최단 경로의 수를 1_000_000_007로 나눈 나머지로 저장해줌
                dp[i][j] %= 1_000_000_007;
            }
        }
        
        answer = dp[n][m]; // 해당 좌표까지의 경로의 수 결과값에 저장
        
        return answer;
    }
}