class Solution {
    public int solution(int sticker[]) {
        int answer = 0;
        
        int n = sticker.length; // 스티커 배열의 길이 저장
        
        // 스티커가 1개만 있을 경우
        if (n == 1) {
            // 그 값이 최대값이 되므로 해당 스티커 값 바로 반환
            return sticker[0];
        }
        
        // 첫 번재 스티커를 선택 (뜯어내는)하는 경우 dp 배열
        int[] dp1 = new int[n]; // [0] ~ [n-1]
        dp1[0] = sticker[0]; // 첫 번째 스티커 선택했으므로 해당 스티커 값 저장 
        dp1[1] = sticker[0]; // 두 번째 스티커는 선택할 수 없으므로 dp[1]도 첫 번째 스티커값에 저장
        
        // 첫 번째 스티커를 선택하는 경우는 마지막 스티커를 선택하지 못하므로 (서로 연결) 마지막 스티커는 제외하고 dp 계산
        for (int i=2; i<n-1; i++) {
            // dp1[i-1]: 이전 스티커를 선택한 경우, 즉 현재 스티커를 선택하지 못하므로 이전 스티커까지의 최대 합
            // dp1[i-2] + sticker[i]: 이전 스티커를 선택하지 않는 경우, 즉 현재 스티커를 선택할 때
            // 두 칸 전까지의 최대 합 + 현재 스티커 값 = dp2[i-2] + sticker[i]
            // 이 중 최대값을 선택해서 dp1[i]에 저장
            dp1[i] = Math.max(dp1[i-1], dp1[i-2] + sticker[i]);
        }
        
        // 첫 번째 스티커를 선택하지 않는 (뜯어내지 않는) 경우 dp 배열
        int[] dp2 = new int[n]; // [0] ~ [n-1]
        dp2[1] = sticker[1]; // 첫 번째 스티커를 선택하지 않으므로 두 번째 스티커 값 저장
        
        // 첫 번째 스티커를 선택하지 않는 경우는 마지막 스티커를 선택할 수 있으므로 마지막 스티커까지 고려하여 dp 계산
        for (int i=2; i<n; i++) {
            // dp2[i-1]: 이전 스티커를 선택한 경우, 즉 현재 스티커를 선택하지 못하므로 이전 스티커까지의 최대 합
            // dp2[i-2] + sticker[i]: 이전 스티커를 선택하지 않는 경우, 즉 현재 스티커를 선택할 때
            // 두 칸 전까지의 최대 합 + 현재 스티커 값 = dp2[i-2] + sticker[i]
            // 이 중 최대값을 선택해서 dp2[i]에 저장
            dp2[i] = Math.max(dp2[i-1], dp2[i-2] + sticker[i]);
        }
        
        // dp1[n-2]: 첫 번째 스티커를 선택하는 경우 마지막 스티커를 선택하지 못하므로 n-2 (마지막 스티커 제외)
        // dp2[n-1]: 첫 번째 스티커를 선택하지 않는 경우 마지막 스티커를 선택할 수 있으므로 n-1 (마지막 스티커 포함)
        // 두 경우 중에서 더 큰 값 결과값에 저장
        answer = Math.max(dp1[n-2], dp2[n-1]);

        // 결과값 반환
        return answer;
    }
}